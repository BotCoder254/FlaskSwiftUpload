<div align="center">

<img src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQwIiBoZWlnaHQ9IjI0MCIgdmlld0JveD0iMCAwIDI0MCAyNDAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPGRlZnM+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImJnR3JhZCIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0b3AtY29sb3I9IiM0MzM4Q0EiPgogICAgICAgIDxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InN0b3AtY29sb3IiIHZhbHVlcz0iIzQzMzhDQTsjNkQyOEQ5OyM0MzM4Q0EiIGR1cj0iM3MiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIi8+CiAgICAgIDwvc3RvcD4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdG9wLWNvbG9yPSIjNkQyOEQ5Ij4KICAgICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJzdG9wLWNvbG9yIiB2YWx1ZXM9IiM2RDI4RDk7IzdDM0FFRDsjNkQyOEQ5IiBkdXI9IjNzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIvPgogICAgICA8L3N0b3A+CiAgICA8L2xpbmVhckdyYWRpZW50PgogICAgPGZpbHRlciBpZD0iZ2xvdyI+CiAgICAgIDxmZUdhdXNzaWFuQmx1ciBzdGREZXZpYXRpb249IjMiIHJlc3VsdD0iY29sb3JlZEJsdXIiLz4KICAgICAgPGZlTWVyZ2U+CiAgICAgICAgPGZlTWVyZ2VOb2RlIGluPSJjb2xvcmVkQmx1ciIvPgogICAgICAgIDxmZU1lcmdlTm9kZSBpbj0iU291cmNlR3JhcGhpYyIvPgogICAgICA8L2ZlTWVyZ2U+CiAgICA8L2ZpbHRlcj4KICA8L2RlZnM+CgogIDwhLS0gTWFpbiBjaXJjbGUgLS0+CiAgPGNpcmNsZSBjeD0iMTIwIiBjeT0iMTIwIiByPSI5MCIgZmlsbD0idXJsKCNiZ0dyYWQpIiBmaWx0ZXI9InVybCgjZ2xvdykiPgogICAgPGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgdmFsdWVzPSI4NTs5MDs4NSIgZHVyPSIzcyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiLz4KICA8L2NpcmNsZT4KCiAgPCEtLSBEZWNvcmF0aXZlIHJpbmcgLS0+CiAgPGNpcmNsZSBjeD0iMTIwIiBjeT0iMTIwIiByPSI3MCIgc3Ryb2tlPSJyZ2JhKDI1NSwyNTUsMjU1LDAuMikiIHN0cm9rZS13aWR0aD0iMiIgZmlsbD0ibm9uZSI+CiAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJyIiB2YWx1ZXM9IjY1Ozc1OzY1IiBkdXI9IjNzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIvPgogIDwvY2lyY2xlPgoKICA8IS0tIFVwbG9hZCBzeW1ib2wgLS0+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTIwLDEyMCkiIGZpbHRlcj0idXJsKCNnbG93KSI+CiAgICA8IS0tIEFycm93IHN0ZW0gLS0+CiAgICA8bGluZSB4MT0iMCIgeTE9IjI1IiB4Mj0iMCIgeTI9Ii0yNSIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWNhcD0icm91bmQiPgogICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJ5MiIgdmFsdWVzPSItMjU7LTM1Oy0yNSIgZHVyPSIxLjVzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIvPgogICAgPC9saW5lPgogICAgPCEtLSBBcnJvdyBoZWFkIC0tPgogICAgPHBhdGggZD0iTS0yMCwwIEwwLC0yNSBMMjAsMCIgc3Ryb2tlPSJ3aGl0ZSIgc3Ryb2tlLXdpZHRoPSI4IiBmaWxsPSJub25lIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiPgogICAgICA8YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJkIiB2YWx1ZXM9Ik0tMjAsMCBMMCwtMjUgTDIwLDA7TS0yMCwtMTAgTDAsLTM1IEwyMCwtMTA7TS0yMCwwIEwwLC0yNSBMMjAsMCIgZHVyPSIxLjVzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIvPgogICAgPC9wYXRoPgogIDwvZz4KPC9zdmc+" width="240" height="240" alt="FlaskSwiftUpload Logo">

# FlaskSwiftUpload

üöÄ Professional Flask File Upload Module with Advanced Features

[![Python Version](https://img.shields.io/badge/python-3.8%2B-blue.svg)](https://www.python.org/downloads/)
[![MongoDB](https://img.shields.io/badge/mongodb-4.4%2B-green.svg)](https://www.mongodb.com/)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)

## üöÄ Quick Start Guide

### Prerequisites

- Python 3.8+
- MongoDB 4.4+
- libmagic
- FFmpeg (optional, for video processing)

### Installation

```bash
# Clone the repository
git clone <repository-url>
cd vendor

# Install system dependencies
sudo apt-get update
sudo apt-get install -y python3-full python3-pip python3-venv libmagic1 ffmpeg

# Set up MongoDB
curl -fsSL https://pgp.mongodb.com/server-7.0.asc | \
    sudo gpg -o /usr/share/keyrings/mongodb-server-7.0.gpg \
    --dearmor

echo "deb [ arch=amd64,arm64 signed-by=/usr/share/keyrings/mongodb-server-7.0.gpg ] https://repo.mongodb.org/apt/ubuntu jammy/mongodb-org/7.0 multiverse" | \
    sudo tee /etc/apt/sources.list.d/mongodb-org-7.0.list

sudo apt-get update
sudo apt-get install -y mongodb-org
sudo systemctl start mongod
sudo systemctl enable mongod

# Create and activate virtual environment
python3 -m venv venv
source venv/bin/activate

# Install Python dependencies
pip install -r requirements.txt
```

## üéØ Running Examples

### Quickstart

```bash
# run the following commands
setup_environment.sh

# Run the basic example
example/run_example.sh
```

This will start the Flask application on `http://localhost:5000`.

### Advanced Features Demo

```bash
# Run the advanced demo with all features
./run_demo.sh
```

Features demonstrated:
- Chunked uploads
- Image processing
- Video conversion
- Progress tracking
- MongoDB integration

### Running Individual Examples

```bash
cd example
# For image processing demo
./start.sh image_processing

# For video processing demo
./start.sh video_processing

# For chunked upload demo
./start.sh chunked_upload
```

## üîß Configuration

### Environment Variables
```bash
# MongoDB connection
export MONGODB_URI="mongodb://localhost:27017/uploads"

# Storage settings
export UPLOAD_FOLDER="uploads"
export MAX_CONTENT_LENGTH=52428800  # 50MB

# Feature flags
export ALLOWED_EXTENSIONS="jpg,jpeg,png,gif,mp4,pdf"
export ENABLE_SECURITY_SCAN=true
export ENABLE_IMAGE_PROCESSING=true
export ENABLE_VIDEO_PROCESSING=true
```

## üß™ Testing

```bash
# Install test dependencies
pip install pytest pytest-asyncio pytest-cov

# Run all tests
pytest

# Run tests with coverage
pytest --cov=flask_swift_upload tests/
```

## üîç Troubleshooting

### Common Issues

1. MongoDB Connection
```bash
# Check MongoDB status
sudo systemctl status mongod

# Restart if needed
sudo systemctl restart mongod
```

2. Permission Issues
```bash
# Fix upload directory permissions
sudo chown -R $USER:$USER uploads/
chmod 755 uploads/
```

3. Virtual Environment
```bash
# Recreate virtual environment
rm -rf venv
python3 -m venv venv
source venv/bin/activate
pip install -r requirements.txt
```

## üåü Features

- üöÄ High-performance file uploads with chunking
- üìÅ Smart directory organization
- ‚úÖ Advanced MIME validation
- üíæ MongoDB integration
- üìä Real-time statistics
- üîÑ Automatic backups
- üìÖ Custom folder structures
- üîí Security features
- üéØ Progress tracking

## üìö Complete Code Examples

### 1. Basic Upload

```python
from flask import Flask, request
from flask_swift_upload import FileUploader

app = Flask(__name__)

# Basic configuration
uploader = FileUploader(
    upload_folder='uploads',
    allowed_mime_types=['image/jpeg', 'image/png'],
    max_content_length=10 * 1024 * 1024  # 10MB
)

@app.route('/upload', methods=['POST'])
def upload():
    return uploader.handle_request()
```

### 2. Advanced Configuration

```python
from flask_swift_upload import FileUploader, StorageConfig, SecurityConfig

# Full configuration example
uploader = FileUploader(
    # Basic settings
    upload_folder='uploads',
    allowed_mime_types=[
        'image/jpeg', 'image/png', 'image/gif',
        'video/mp4', 'video/quicktime',
        'application/pdf'
    ],
    max_content_length=100 * 1024 * 1024,  # 100MB
    
    # Storage configuration
    storage_config=StorageConfig(
        create_date_subfolders=True,
        max_folder_size=5 * 1024**3,  # 5GB
        backup_old_files=True,
        backup_folder='uploads/backup',
        path_template='{year}/{month}/{day}',
        compression_enabled=True,
        compression_quality=85,
        deduplication_enabled=True
    ),
    
    # Security configuration
    security_config=SecurityConfig(
        hash_filenames=True,
        scan_content=True,
        max_filename_length=255,
        forbidden_extensions=['.php', '.exe', '.js'],
        allowed_origins=['https://trusted-domain.com'],
        require_auth=True
    )
)
```

### 3. MongoDB Integration

```python
from flask import Flask
from flask_pymongo import PyMongo
from flask_swift_upload import FileUploader, MongoStorage
from datetime import datetime

app = Flask(__name__)
app.config["MONGO_URI"] = "mongodb://localhost:27017/uploads"
mongo = PyMongo(app)

# MongoDB storage backend
mongo_storage = MongoStorage(
    mongo_db=mongo.db,
    collection_name='uploads',
    indexes=[
        [('filename', 1)],
        [('uploaded_at', -1)],
        [('user_id', 1)],
        [('mime_type', 1)]
    ]
)

uploader = FileUploader(
    upload_folder='uploads',
    storage_backend=mongo_storage
)

@app.route('/upload', methods=['POST'])
def upload_with_metadata():
    try:
        # Handle file upload
        result = uploader.handle_request()
        
        if result['status'] == 'success':
            # Add metadata
            mongo.db.uploads.update_one(
                {'filename': result['filename']},
                {'$set': {
                    'user_id': request.form.get('user_id'),
                    'tags': request.form.getlist('tags'),
                    'description': request.form.get('description'),
                    'uploaded_at': datetime.utcnow()
                }}
            )
        
        return result
    except Exception as e:
        return {'status': 'error', 'message': str(e)}, 500
```

### 4. Chunked Upload Support

```python
from flask_swift_upload import ChunkedUploader

chunked_uploader = ChunkedUploader(
    upload_folder='uploads/chunks',
    chunk_size=1024 * 1024,  # 1MB chunks
    max_chunks=1000,
    cleanup_incomplete=True,
    incomplete_timeout=3600  # 1 hour
)

@app.route('/upload/chunked', methods=['POST'])
def chunked_upload():
    chunk_number = int(request.form['chunk_number'])
    total_chunks = int(request.form['total_chunks'])
    file_id = request.form['file_id']
    
    result = chunked_uploader.handle_chunk(
        file=request.files['chunk'],
        file_id=file_id,
        chunk_number=chunk_number,
        total_chunks=total_chunks
    )
    
    if result['status'] == 'completed':
        # Process completed file
        final_file = result['file_path']
        success, message, filename = uploader.save_file(final_file)
        return {'status': 'success', 'filename': filename}
    
    return result
```

### 5. Image Processing

```python
from flask_swift_upload import ImageProcessor, ProcessingConfig

# Image processing configuration
processing_config = ProcessingConfig(
    # Resize settings
    resize_enabled=True,
    max_dimensions=(1920, 1080),
    preserve_aspect_ratio=True,
    
    # Optimization settings
    optimize_images=True,
    compression_quality=85,
    convert_format='JPEG',
    
    # Thumbnail settings
    create_thumbnails=True,
    thumbnail_sizes=[(150, 150), (300, 300)],
    
    # Watermark settings
    add_watermark=True,
    watermark_image='watermark.png',
    watermark_position='bottom-right',
    watermark_opacity=0.7
)

# Initialize processor
image_processor = ImageProcessor(processing_config)

@app.route('/upload/image', methods=['POST'])
def process_and_upload_image():
    if 'file' not in request.files:
        return {'error': 'No file part'}, 400
    
    file = request.files['file']
    
    # Process image before saving
    processed_file = image_processor.process(file)
    
    # Save processed file
    success, message, filename, details = uploader.save_file(processed_file)
    
    if success:
        return {
            'status': 'success',
            'filename': filename,
            'thumbnails': details['thumbnails'],
            'dimensions': details['dimensions']
        }
    
    return {'status': 'error', 'message': message}, 400
```

### 6. Video Processing

```python
from flask_swift_upload import VideoProcessor, VideoConfig

video_config = VideoConfig(
    # Format settings
    output_format='mp4',
    video_codec='h264',
    audio_codec='aac',
    
    # Quality settings
    resolution='1080p',
    bitrate='4M',
    
    # Thumbnail settings
    generate_thumbnail=True,
    thumbnail_time='00:00:02',
    
    # Preview settings
    generate_preview=True,
    preview_duration=10,
    preview_fps=1
)

video_processor = VideoProcessor(video_config)

@app.route('/upload/video', methods=['POST'])
def process_and_upload_video():
    if 'file' not in request.files:
        return {'error': 'No file part'}, 400
    
    file = request.files['file']
    
    # Process video
    processed_video = video_processor.process(file)
    
    # Save processed video
    success, message, filename, details = uploader.save_file(processed_video)
    
    if success:
        return {
            'status': 'success',
            'filename': filename,
            'thumbnail': details['thumbnail'],
            'preview': details['preview'],
            'duration': details['duration']
        }
    
    return {'status': 'error', 'message': message}, 400
```

### 7. Progress Tracking

```python
from flask_swift_upload import ProgressTracker
import json

progress_tracker = ProgressTracker(
    storage_backend='redis',  # or 'memory'
    cleanup_interval=3600,    # cleanup old records every hour
    expire_time=86400        # expire records after 24 hours
)

@app.route('/upload/with-progress', methods=['POST'])
def upload_with_progress():
    upload_id = progress_tracker.start_upload(
        total_size=request.content_length,
        filename=request.files['file'].filename
    )
    
    def progress_callback(bytes_uploaded):
        progress_tracker.update_progress(upload_id, bytes_uploaded)
    
    try:
        result = uploader.save_file(
            request.files['file'],
            progress_callback=progress_callback
        )
        
        progress_tracker.complete_upload(upload_id)
        return {'status': 'success', 'upload_id': upload_id}
    except Exception as e:
        progress_tracker.fail_upload(upload_id, str(e))
        return {'status': 'error', 'message': str(e)}, 400

@app.route('/upload/progress/<upload_id>')
def get_progress(upload_id):
    return progress_tracker.get_progress(upload_id)
```

### 8. Validation and Security

```python
from flask_swift_upload import SecurityValidator, ValidationError

class CustomValidator(SecurityValidator):
    def validate_content(self, file_stream):
        """Custom content validation."""
        # Check file signature
        magic_bytes = file_stream.read(4)
        file_stream.seek(0)
        
        if magic_bytes.startswith(b'PK'):
            raise ValidationError("ZIP files not allowed")
        
        return True
    
    def validate_filename(self, filename):
        """Custom filename validation."""
        forbidden = ['temp', 'test', 'backup']
        
        for word in forbidden:
            if word in filename.lower():
                raise ValidationError(f"Filename cannot contain '{word}'")
        
        return True

# Use custom validator
uploader = FileUploader(
    upload_folder='uploads',
    validator=CustomValidator(),
    security_config={
        'scan_content': True,
        'max_filename_length': 255,
        'forbidden_extensions': ['.php', '.exe']
    }
)
```

### 9. File Management API

```python
@app.route('/files', methods=['GET'])
def list_files():
    page = int(request.args.get('page', 1))
    per_page = int(request.args.get('per_page', 20))
    file_type = request.args.get('type')
    
    # Build query
    query = {}
    if file_type:
        query['mime_type'] = {'$regex': f'^{file_type}/'}
    
    # Get files
    files = list(mongo.db.uploads.find(query)
                .sort('uploaded_at', -1)
                .skip((page - 1) * per_page)
                .limit(per_page))
    
    total = mongo.db.uploads.count_documents(query)
    
    return {
        'files': [{
            'id': str(f['_id']),
            'filename': f['filename'],
            'original_filename': f['original_filename'],
            'mime_type': f['mime_type'],
            'size': f['size'],
            'uploaded_at': f['uploaded_at'].isoformat(),
            'url': f"/files/{f['filename']}"
        } for f in files],
        'total': total,
        'page': page,
        'pages': (total + per_page - 1) // per_page
    }

@app.route('/files/<filename>', methods=['GET'])
def serve_file(filename):
    file_doc = mongo.db.uploads.find_one({'filename': filename})
    if not file_doc:
        return {'error': 'File not found'}, 404
    
    return send_from_directory(
        uploader.upload_folder,
        filename,
        as_attachment=request.args.get('download') == 'true'
    )

@app.route('/files/<filename>', methods=['DELETE'])
def delete_file(filename):
    file_doc = mongo.db.uploads.find_one_and_delete({'filename': filename})
    if not file_doc:
        return {'error': 'File not found'}, 404
    
    try:
        uploader.delete_file(filename)
        return {'status': 'success'}
    except Exception as e:
        return {'status': 'error', 'message': str(e)}, 500
```

### 10. Storage Statistics

```python
@app.route('/stats')
def get_stats():
    # Get basic stats
    total_files = mongo.db.uploads.count_documents({})
    total_size = sum(f['size'] for f in mongo.db.uploads.find({}, {'size': 1}))
    
    # Get MIME type distribution
    mime_stats = list(mongo.db.uploads.aggregate([
        {'$group': {
            '_id': '$mime_type',
            'count': {'$sum': 1},
            'total_size': {'$sum': '$size'}
        }},
        {'$sort': {'count': -1}}
    ]))
    
    # Get upload trends
    from datetime import datetime, timedelta
    last_week = datetime.utcnow() - timedelta(days=7)
    
    daily_uploads = list(mongo.db.uploads.aggregate([
        {'$match': {'uploaded_at': {'$gte': last_week}}},
        {'$group': {
            '_id': {
                'year': {'$year': '$uploaded_at'},
                'month': {'$month': '$uploaded_at'},
                'day': {'$dayOfMonth': '$uploaded_at'}
            },
            'count': {'$sum': 1},
            'size': {'$sum': '$size'}
        }},
        {'$sort': {'_id': 1}}
    ]))
    
    return {
        'summary': {
            'total_files': total_files,
            'total_size': total_size,
            'average_size': total_size / total_files if total_files > 0 else 0
        },
        'mime_types': mime_stats,
        'daily_uploads': daily_uploads,
        'storage': uploader.get_storage_stats()
    }
```

## üîß Configuration Reference

### FileUploader Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| upload_folder | str/Path | required | Base directory for uploads |
| allowed_mime_types | List[str] | None | Allowed MIME types |
| max_content_length | int | 16MB | Maximum file size |
| use_timestamp | bool | True | Add timestamps to filenames |
| hash_filenames | bool | False | Hash filenames |

### Storage Configuration

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| create_date_subfolders | bool | False | Use date folders |
| max_folder_size | int | None | Max folder size |
| backup_old_files | bool | False | Create backups |
| backup_folder | str/Path | None | Backup location |
| path_template | str | '{year}/{month}/{day}' | Folder structure |

## üìù License

MIT License - see [LICENSE](LICENSE) for details.

<div align="center">

Made with ‚ù§Ô∏è by the FlaskSwiftUpload Team

</div>
